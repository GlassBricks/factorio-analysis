package glassbricks.factorio.prototypecodegen

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import glassbricks.factorio.prototypecodegen.PrototypeDeclarationsGenerator.TypeContext.InnerType
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.UseSerializers
import kotlinx.serialization.json.JsonNames
import kotlinx.serialization.json.booleanOrNull
import kotlinx.serialization.json.doubleOrNull

const val PACKAGE_NAME = "glassbricks.factorio.prototypes"
const val PAR_PACKAGE_NAME = "glassbricks.factorio.blueprint"
private fun String.toClassName() = ClassName(PACKAGE_NAME, this)


@OptIn(ExperimentalSerializationApi::class)
class PrototypeDeclarationsGenerator(private val input: GeneratedPrototypes) {
    fun generate(): List<FileSpec> {
        return listOf(generatePrototypesFile(), generateConceptsFile(), generateDataRaw())
    }

    private val conceptSealedIntfs = input.concepts.values.filter { it.isSealedIntf }.associate { genConcept ->
        val concept = genConcept.inner
        val options = (concept.type as? UnionType)?.let { getBasicTypes(it) }
            ?: error("Sealed interface must be a union of basic types")
        concept.name to SealedIntf(
            genConcept.inner.name,
            superTypes = concept.parent?.let { listOf(it) }.orEmpty(),
            subtypes = options,
            modify = null
        )
    }
    private val sealedIntfs = conceptSealedIntfs.values + input.extraSealedIntfs
    private val sealedIntfByOptions = sealedIntfs.associateBy { it.subtypes }

    private val sealedSupertypes =
        sealedIntfs
            .flatMap { it.subtypes.map { subType -> subType to it.name } }
            .groupBy({ it.first }, { it.second })

    private val hasInheritors = mutableSetOf<String>()

    init {
        for (prototype in input.prototypes.values + input.concepts.values) {
            val parent = prototype.inner.parent
            if (parent != null) {
                hasInheritors.add(parent)
            }
        }
    }

    private val generatedEnumNames = mutableSetOf<String>()
    private val enumValuesToName = mutableMapOf<Set<String>, String>()

    init {
        for ((_, concept) in input.concepts) {
            if (concept.inner.type is UnionType) {
                val options = tryGetEnumOptions(concept.inner.type)
                if (options != null) {
                    generatedEnumNames += concept.inner.name
                }
            }
        }
    }

    private fun newFile(name: String) = FileSpec.builder(PACKAGE_NAME, name).apply {
        indent("    ")
        addFileComment("Generated by prototype-codegen")
        addAnnotation(
            AnnotationSpec.builder(Suppress::class.asClassName())
                .addMember("%S", "EnumEntryName")
                .addMember("%S", "PropertyName")
                .build()
        )
        addAnnotation(
            AnnotationSpec.builder(UseSerializers::class)
                .addMember("PositionShorthandSerializer::class")
                .addMember("BoundingBoxShorthandSerializer::class")
                .addMember("LuaListSerializer::class")
                .addMember("DoubleAsIntSerializer::class")
                .build()
        )
        addKotlinDefaultImports()
    }

    private fun generatePrototypesFile(): FileSpec {
        val file = newFile("Prototypes")
        for (prototype in input.prototypes.values.sortedBy { it.inner.order }) {
            file.addType(generatePrototype(file, prototype))
            if (prototype.inner.parent != null) {
                checkNotNull(input.prototypes[prototype.inner.parent]) {
                    "Parent of ${prototype.inner.name} (${prototype.inner.parent}) not defined"
                }
            }
        }
        return file.build()
    }

    private fun generateConceptsFile(): FileSpec {
        val file = newFile("Concepts")
        generateConcepts(file)
        generateExtraSealedIntfs(file)
        return file.build()
    }

    private fun generateConcepts(file: FileSpec.Builder) {
        for (concept in input.concepts.values.sortedBy { it.inner.order }) {
            val parent = concept.inner.parent
            if (parent != null && parent != "BaseEnergySource") {
                input.concepts[parent] ?: error("Parent concept not found: $parent")
            }
            val type = generateConcept(file, concept)
            if (type is TypeAliasSpec) {
                file.addTypeAlias(type)
            } else if (type is TypeSpec) {
                file.addType(type)
            }
        }
    }


    private fun generateExtraSealedIntfs(file: FileSpec.Builder) {
        for (intf in input.extraSealedIntfs) {
            val type = generateSealedIntf(intf).build()
            file.addType(type)
        }
    }

    private fun generateSealedIntf(intf: SealedIntf): TypeSpec.Builder = TypeSpec.interfaceBuilder(intf.name).apply {
        addAnnotation(Serializable::class)
        addModifiers(KModifier.SEALED)
        for (supertype in intf.superTypes) {
            addSuperinterface(supertype.toClassName())
        }
        intf.modify?.invoke(this)
    }

    private fun generateDataRaw(): FileSpec {
        val file = newFile("Data")
        val allPrototypes = TypeSpec.classBuilder("DataRaw").apply {
            addKdoc(
                "Models [data.raw](https://wiki.factorio.com/Data.raw). " +
                        "This only contains a subset of objects and properties, that are used by this library."
            )
            addAnnotation(Serializable::class)

            val constructorBuilder = FunSpec.constructorBuilder()
            for (prototype in input.prototypes.values) {
                val typeName = prototype.inner.typename ?: continue
                val mapType = Map::class.asClassName().parameterizedBy(
                    String::class.asClassName(),
                    prototype.inner.name.toClassName()
                )
                addProperty(
                    PropertySpec.builder(typeName, mapType)
                        .initializer(typeName)
                        .build()
                )
                constructorBuilder.addParameter(
                    ParameterSpec.builder(typeName, mapType)
                        .defaultValue("emptyMap()")
                        .build()
                )
            }

            primaryConstructor(constructorBuilder.build())
        }.build()

        file.addType(allPrototypes)

        generateAllSubclassGetters(file)
        return file.build()
    }

    private fun generateAllSubclassGetters(file: FileSpec.Builder) {
        for (baseProtoName in input.allSubclassGetters) {
            input.prototypes[baseProtoName] ?: error("Base prototype not found: $baseProtoName")
            val subclasses = getAllPrototypeSubclasses(input.prototypes.mapValues { it.value.inner }, baseProtoName)
                .filter { it.typename != null }
                .sortedBy { it.order }
                .map { it.typename!! }
            // fun DataRaw.all(BasePrototypes)s(): List<BaseClass> = listOf(
            //      `typename`,*
            // ).flatMap { it.values }
            val function = FunSpec.builder("all${baseProtoName}s").apply {
                addKdoc("All prototypes that are subclasses of $baseProtoName.")
                receiver("DataRaw".toClassName())
                returns(List::class.asClassName().parameterizedBy(baseProtoName.toClassName()))
                addCode(buildCodeBlock {
                    add("return listOf(\n")
                    withIndent {
                        for (subclass in subclasses) {
                            add("%N,\n", subclass)
                        }
                    }
                    add(").flatMap { it.values }")
                })
            }.build()
            file.addFunction(function)
        }
    }


    private fun generatePrototype(file: FileSpec.Builder, prototype: GeneratedPrototype): TypeSpec =
        generateClass(file, prototype, prototype.inner.name)

    private fun generateClass(
        file: FileSpec.Builder,
        value: GeneratedValue,
        name: String,
        isDataClass: Boolean = false
    ): TypeSpec {
        val canBeObject =
            value.includedProperties.isEmpty()
                    && value.typeName != null
                    && value.inner.name !in hasInheritors
                    && value.inner.parent.let {
                it == "BaseEnergySource"
            }

        val builder = if (canBeObject) {
            TypeSpec.objectBuilder(name)
        } else {
            TypeSpec.classBuilder(name)
        }
        return builder.apply {
            // doc
            addDescription(value.inner.description)

            // annotations
            addAnnotation(Serializable::class)
            val typeName = value.typeName
            if (typeName != null) {
                addAnnotation(
                    AnnotationSpec.builder(SerialName::class)
                        .addMember("%S", typeName)
                        .build()
                )
            }

            // modifiers
            if (isDataClass) {
                addModifiers(KModifier.DATA)
            }

            if (!isDataClass) {
                if (value.inner.abstract) {
                    addModifiers(KModifier.ABSTRACT)
                } else {
                    addModifiers(KModifier.OPEN)
                }
            }

            val hasInheritors = value.inner.name in hasInheritors
            if (value.inner.abstract) check(hasInheritors)

            // supertypes
            val parent = value.inner.parent
            if (parent != null) {
                if (parent == "BaseEnergySource") {
                    addSuperinterface("EnergySource".toClassName())
                } else {
                    check(parent in input.prototypes || parent in input.concepts) {
                        "Parent prototype not found: $parent"
                    }
                    superclass(ClassName(PACKAGE_NAME, parent))
                }
            }
            val sealedSupertypes = sealedSupertypes[value.inner.name]
            if (sealedSupertypes != null) {
                for (extra in sealedSupertypes) {
                    addSuperinterface(extra.toClassName())
                }
            }

            // properties
            if (isDataClass) {
                val constructorBuilder = FunSpec.constructorBuilder()
                for (property in value.includedProperties.values.sortedBy { it.inner.order }) {
                    val (propertySpec, defaultValue) = generateProperty(file, value, property, initByMutate = false) {
                        initializer(property.inner.name)
                    }
                    addProperty(propertySpec)
                    constructorBuilder.addParameter(
                        ParameterSpec.builder(propertySpec.name, propertySpec.type)
                            .defaultValue(defaultValue)
                            .build()
                    )
                }
                if (constructorBuilder.parameters.isNotEmpty())
                    primaryConstructor(constructorBuilder.build())
            } else {
                for (property in value.includedProperties.values.sortedBy { it.inner.order }) {
                    addProperty(generateProperty(file, value, property, initByMutate = true).first)
                }
            }

            value.modify?.invoke(this)
        }.build()
    }

    private fun Concept.canBeDataClass(): Boolean =
        !properties.isNullOrEmpty() && name !in hasInheritors

    private fun generateStructConcept(
        file: FileSpec.Builder,
        concept: GeneratedConcept,
        name: String,
    ): TypeSpec {
        return generateClass(file, concept, name, isDataClass = concept.inner.canBeDataClass())
    }

    private fun generateConcept(
        file: FileSpec.Builder,
        concept: GeneratedConcept
    ): Any {
        val type = when {
            concept.overrideType != null -> {
                val (type, declaration) = concept.overrideType
                TransformedType(type, declaration)
            }

            concept.isSealedIntf -> TransformedType(
                typeName = concept.inner.name.toClassName(),
                declaration = generateSealedIntf(conceptSealedIntfs[concept.inner.name]!!).build()
            )

            else -> mapTypeDefinition(
                file, concept.inner.type,
                TypeContext.Concept(file, concept)
            )
        }
        if (type.declaration != null) {
            return type.declaration
        }
        return TypeAliasSpec.builder(concept.inner.name, type.putType(file)).apply {
            addDescription(concept.inner.description)
        }.build()
    }

    /**
     * Gets the name of the builtin type, if it is a builtin type.
     * Follows concepts which are only type aliases.
     */
    private tailrec fun TypeDefinition.getBuiltinType(): String? {
        val type = (innerType() as? BasicType)?.value ?: return null
        if (type in input.builtins) return type
        val concept = input.concepts[type] ?: return null
        return concept.inner.type.getBuiltinType()
    }

    private fun getDefaultValue(property: Property, type: TypeName): CodeBlock? {
        return when (val default = property.default) {
            is ManualDefault -> default.value
            is LiteralDefault -> {
                val value = default.value
                if (value.isString) {
                    if (type is ClassName && type.simpleName in generatedEnumNames) {
                        // enumType.value
                        CodeBlock.of("%T.%N", type, value.content)
                    } else {
                        CodeBlock.of("%S", value.content)
                    }
                } else {
                    val builtinType = property.type.getBuiltinType()
                    value.booleanOrNull?.let {
                        require(builtinType == "bool")
                        CodeBlock.of("%L", it)
                    } ?: value.doubleOrNull?.let {
                        when {
                            builtinType == null -> error("Got numeric default for non-numeric type")
                            builtinType == "double" -> CodeBlock.of("%L", it)
                            builtinType == "float" -> CodeBlock.of("%Lf", it.toFloat().toString())
                            builtinType.contains("uint") -> CodeBlock.of("%Lu", it.toULong())
                            builtinType.contains("int") -> CodeBlock.of("%L", it.toLong())
                            else -> error("Unhandled builtin type: $builtinType")
                        }
                    }
                    ?: error("Unhandled literal type: $value")
                }
            }

            else -> null
        }
    }

    private fun getPlaceholderValue(property: Property): CodeBlock? {
        val builtinType = property.type.getBuiltinType()
        return when {
            builtinType == null -> null
            builtinType == "double" -> CodeBlock.of("0.0")
            builtinType == "float" -> CodeBlock.of("0f")
            builtinType == "bool" -> CodeBlock.of("false")
            builtinType.contains("uint") -> CodeBlock.of("0u")
            builtinType.contains("int") -> CodeBlock.of("0")
            else -> null
        }?.let {
            CodeBlock.of("required(%L)", it)
        }
    }

    private fun generateProperty(
        file: FileSpec.Builder,
        context: GeneratedValue,
        genProperty: PropertyOptions,
        initByMutate: Boolean,
        block: PropertySpec.Builder.() -> Unit = {}
    ): Pair<PropertySpec, CodeBlock?> {
        val property = genProperty.inner

        val basicType =
            genProperty.overrideType ?: mapTypeDefinition(
                file, property.type,
                TypeContext.Property(file, context, genProperty)
            ).putType(file)
        val defaultValue = getDefaultValue(property, basicType)
        val type =
            basicType.copy(nullable = property.optional && defaultValue == null)

        val propertySpec = PropertySpec.builder(property.name, type).apply {
            addDescription(property.description)
            if (property.alt_name != null) {
                addAnnotation(
                    AnnotationSpec.builder(JsonNames::class)
                        .addMember("%S", property.alt_name)
                        .build()
                )
            }

            if (initByMutate) {
                mutable()
                if (defaultValue != null) {
                    initializer(defaultValue)
                } else if (property.optional) {
                    initializer("null")
                } else {
                    val placeholderValue = getPlaceholderValue(property)
                    if (placeholderValue != null) {
                        initializer(placeholderValue)
                    } else {
                        addModifiers(KModifier.LATEINIT)
                    }
                }
                setter(FunSpec.setterBuilder().addModifiers(KModifier.PROTECTED).build())
            }

            block()
            genProperty.modify?.invoke(this)
        }.build()
        return propertySpec to defaultValue
    }


    private fun tryGetEnumOptions(type: TypeDefinition): List<LiteralType>? =
        if (type is UnionType && type.options.all { it is LiteralType && it.value.isString }) {
            @Suppress("UNCHECKED_CAST")
            type.options as List<LiteralType>
        } else {
            null
        }

    private fun generateEnumType(
        name: String,
        options: List<LiteralType>,
        block: TypeSpec.Builder.() -> Unit = {}
    ): TypeSpec? {
        val stringOptions = options.map { it.value.content }.toSet()
        if (stringOptions in enumValuesToName) {
            require(enumValuesToName[stringOptions] == name) {
                "Enum with same options but different name already exists: ${enumValuesToName[stringOptions]}"
            }
            return null
        }
        enumValuesToName[stringOptions] = name

        return TypeSpec.enumBuilder(name).apply {
            addAnnotation(Serializable::class)

            for (option in options) {
                addEnumConstant(
                    option.value.content,
                    TypeSpec.anonymousClassBuilder().apply {
                        addDescription(option.description)
                    }.build()
                )
            }

            block()
        }.build()
            .also { generatedEnumNames += name }
    }


    private fun tryGetItemOrArrayValue(
        type: UnionType
    ): TypeDefinition? {
        if (type.options.size != 2) return null
        val (first, second) = type.options
        if (second !is ArrayType || first != second.value) return null
        return first
    }

    private fun tryGetSealedIntf(type: UnionType): TypeName? {
        val options = getBasicTypes(type)
        return sealedIntfByOptions[options]?.name?.toClassName()
    }

    private fun getBasicTypes(type: UnionType): Set<String>? {
        val typeOptions = type.options.map { it.innerType() }
        if (!typeOptions.all { it is BasicType && it.value in input.concepts }) return null
        return typeOptions.map { (it as BasicType).value }.toSet()
    }

    private class TransformedType(
        private val typeName: TypeName,
        val declaration: TypeSpec?
    ) {
        fun putType(file: FileSpec.Builder): TypeName {
            if (declaration != null) {
                file.addType(declaration)
            }
            return typeName
        }
    }

    private sealed interface RootTypeContext : TypeContext
    private sealed interface TypeContext {

        val file: FileSpec.Builder
        val parentType: GeneratedValue

        class Concept(
            override val file: FileSpec.Builder,
            override val parentType: GeneratedConcept
        ) : RootTypeContext

        class Property(
            override val file: FileSpec.Builder,
            override val parentType: GeneratedValue,
            val property: PropertyOptions
        ) : RootTypeContext

        class InnerType(val parentContext: TypeContext) : TypeContext {
            override val file: FileSpec.Builder get() = parentContext.file
            override val parentType: GeneratedValue get() = parentContext.parentType
        }
    }

    private fun TypeName.toGenType() = TransformedType(this, null)
    private fun mapTypeDefinition(
        file: FileSpec.Builder,
        type: TypeDefinition,
        context: TypeContext,
    ): TransformedType {
        val parentType = context.parentType
        return when (type) {
            is BasicType -> {
                val value = type.value
                if (value in input.predefined) {
                    input.predefined[value]!!.toGenType()
                } else {
                    check(
                        value in input.concepts || input.extraSealedIntfs.any { value == it.name }
                    ) {
                        "Type not in generated concepts: $value"
                    }
                    value.toClassName().toGenType()
                }
            }

            is ArrayType -> List::class.asClassName()
                .parameterizedBy(mapTypeDefinition(file, type.value, InnerType(context)).putType(file))
                .toGenType()

            is DictType -> Map::class.asClassName()
                .parameterizedBy(
                    mapTypeDefinition(file, type.key, InnerType(context)).putType(file),
                    mapTypeDefinition(file, type.value, InnerType(context)).putType(file),
                )
                .toGenType()

            is LiteralType -> {
                val value = type.value
                when {
                    value.isString -> "UnknownStringLiteral".toClassName().toGenType()
                    else -> error("Unhandled literal type: $value")
                }
            }

            is TypeType -> mapTypeDefinition(file, type.value, context)
            StructType -> {
                val parentName = parentType.inner.name
                val name = if (context is TypeContext.Concept) {
                    parentName
                } else {
                    parentName + "Values"
                }
                check(parentType is GeneratedConcept)
                TransformedType(name.toClassName(), generateStructConcept(file, parentType, name))
            }

            is TupleType -> error("TupleType not supported")
            is UnionType -> tryGetEnumOptions(type)?.let { options ->
                val parentName = parentType.inner.name
                val name = when (context) {
                    is TypeContext.Concept -> parentName
                    is TypeContext.Property -> context.property.innerEnumName
                        ?: error("Inner enum name not specified for ${parentName}.${context.property.inner.name}")

                    is InnerType -> {
                        check(parentType is GeneratedConcept)
                        parentType.innerEnumName ?: error("Inner enum name not specified for $parentName")
                        // not handling more complicated relationships yet
                    }
                }
                val enumType = generateEnumType(name, options) {
                    if (context is TypeContext.Concept) {
                        addDescription(context.parentType.inner.description)
                    }
                }
                TransformedType(name.toClassName(), enumType)
            } ?: tryGetItemOrArrayValue(type)?.let { item ->
                "ItemOrArray".toClassName()
                    .parameterizedBy(mapTypeDefinition(file, item, InnerType(context)).putType(file))
                    .toGenType()
            } ?: tryGetSealedIntf(type)?.toGenType()
            ?: error("UnionType $type not supported")
        }
    }

}

fun Documentable.Builder<*>.addDescription(description: String?) {
    if (!description.isNullOrBlank()) {
        addKdoc("%L", description)
    }
}
